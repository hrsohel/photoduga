import React, { useState, useEffect, useRef } from "react";
import { Stage, Layer, Image as KonvaImage, Text, Group, Transformer, Rect, Circle } from "react-konva";
import useImage from "use-image";
import { layouts, realImages, stickerImages } from "../../../data/imagesForPhotoAlbum";

const loadImage = async (src) => {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = src;
    img.onload = () => resolve(img);
    img.onerror = () => resolve(new Image());
  });
};

function ImageEditor({ image, onClose, onDelete, onResize, onZoom, transformerRef, selectedImage }) {
  const handleZoomIn = () => {
    onZoom(selectedImage.scale * 1.1);
  };
  const handleZoomOut = () => {
    onZoom(selectedImage.scale * 0.9);
  };
  return (
    <div
      style={{
        position: "absolute",
        top: "20px",
        left: "20px",
        zIndex: 10,
        background: "white",
        padding: "20px",
        borderRadius: "8px",
        boxShadow: "0 0 10px rgba(0,0,0,0.1)",
      }}
    >
      <h2>Edit Image</h2>
      <div>
        <button onClick={handleZoomIn}>Zoom In</button>
        <button onClick={handleZoomOut}>Zoom Out</button>
        <button onClick={onResize}>Apply Resize</button>
        <button onClick={onClose}>Close</button>
        <button onClick={onDelete}>Delete</button>
      </div>
    </div>
  );
}

export default function AlbumPage() {
  const [bgUrl, setBgUrl] = useState("https://via.placeholder.com/1200x800?text=Background");
  const [selectedImageIndex, setSelectedImageIndex] = useState(null);
  const [selectedStickerIndex, setSelectedStickerIndex] = useState(null);
  const [contextMenu, setContextMenu] = useState({
    visible: false,
    x: 0,
    y: 0,
    type: null,
    stickerIndex: null,
    imageIndex: null,
    textIndex: null,
    shapeIndex: null,
  });
  const [selectedSticker, setSelectedSticker] = useState({ imageIndex: null, stickerIndex: null });
  const [selectedShapeIndex, setSelectedShapeIndex] = useState(null);
  const [shapeDialog, setShapeDialog] = useState({ visible: false, index: null, type: null, shapeType: null });
  const [gridCount, setGridCount] = useState(6);
  const [isGridChanging, setIsGridChanging] = useState(false);

  const [texts, setTexts] = useState([]);
  const [shapes, setShapes] = useState([]);

  const [images, setImages] = useState(
    realImages.map((src, i) => ({
      src,
      scale: 1,
      isSelected: false,
      x: 0,
      y: 0,
      stickers: [],
      texts: [],
      zIndex: 0,
    }))
  );

  const [bg] = useImage(bgUrl);
  const transformerRef = useRef(null);
  const stickerTransformerRef = useRef(null);
  const textTransformerRef = useRef(null);
  const shapeTransformerRef = useRef(null);
  const [loadedImages, setLoadedImages] = useState([]);
  const [loadedStickers, setLoadedStickers] = useState([]);
  const imageRefs = useRef(images.map(() => React.createRef()));
  const shapeRefs = useRef([]);

  useEffect(() => {
    const loadImages = async () => {
      const imagePromises = images.map((img) => loadImage(img.src));
      const loaded = await Promise.all(imagePromises);
      setLoadedImages(loaded);
    };
    loadImages();
  }, [images]);

  useEffect(() => {
    const loadStickers = async () => {
      const stickerPromises = stickerImages.map((src) => loadImage(src));
      const loaded = await Promise.all(stickerPromises);
      setLoadedStickers(loaded);
    };
    loadStickers();
  }, []);

  // Generate grid layout (rects & circles in different patterns)
  const generateGridLayout = (count) => {
    const stageWidth = 1200;
    const stageHeight = 800;
    const padding = 20;
    const cols = Math.ceil(Math.sqrt(count));
    const rows = Math.ceil(count / cols);
    const cellWidth = (stageWidth - padding * (cols + 1)) / cols;
    const cellHeight = (stageHeight - padding * (rows + 1)) / rows;

    const gridLayout = [];
    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      gridLayout.push({
        x: padding + col * (cellWidth + padding),
        y: padding + row * (cellHeight + padding),
        width: cellWidth,
        height: cellHeight,
        shape: (row + col) % 2 === 0 ? "rect" : "circle",
      });
    }
    return gridLayout;
  };

  const getCurrentGridLayout = () => generateGridLayout(gridCount);

  // Handle grid count change with animation
  const addGridCell = () => {
    if (gridCount < 12) {
      setIsGridChanging(true);
      setTimeout(() => {
        setGridCount(gridCount + 1);
        if (gridCount < realImages.length) {
          const newImage = {
            src: realImages[gridCount],
            scale: 1,
            isSelected: false,
            x: 0,
            y: 0,
            stickers: [],
            texts: [],
            zIndex: 0,
          };
          setImages([...images, newImage]);
        }
        setIsGridChanging(false);
      }, 300);
    }
  };

  const removeGridCell = () => {
    if (gridCount > 1) {
      setIsGridChanging(true);
      setTimeout(() => {
        setGridCount(gridCount - 1);
        if (images.length > gridCount) {
          const updatedImages = [...images];
          updatedImages.pop();
          setImages(updatedImages);
        }
        setIsGridChanging(false);
      }, 300);
    }
  };

  const shuffleGrid = () => {
    setIsGridChanging(true);
    setTimeout(() => {
      const shuffledImages = [...images];
      for (let i = shuffledImages.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledImages[i], shuffledImages[j]] = [shuffledImages[j], shuffledImages[i]];
      }
      setImages(shuffledImages);
      setIsGridChanging(false);
    }, 300);
  };

  // Text editing helper
  const startEditingText = (node, isParent, imageIndex, textIndex) => {
    const stage = node.getStage();
    const stageBox = stage.container().getBoundingClientRect();
    const pos = node.absolutePosition();
    const area = document.createElement("textarea");
    document.body.appendChild(area);
    area.value = node.text();
    area.style.position = "absolute";
    area.style.top = stageBox.top + pos.y + "px";
    area.style.left = stageBox.left + pos.x + "px";
    area.style.width = node.width() + "px";
    area.style.fontSize = node.fontSize() + "px";
    area.style.border = "1px solid #ccc";
    area.style.background = "white";
    area.focus();
    area.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const value = area.value;
        if (isParent) {
          const updated = [...texts];
          updated[textIndex].text = value;
          setTexts(updated);
        } else {
          const updated = [...images];
          updated[imageIndex].texts[textIndex].text = value;
          setImages(updated);
        }
        document.body.removeChild(area);
      }
    });
  };

  const handleImageClick = (index, e) => {
    e.cancelBubble = true;
    if (selectedStickerIndex !== null) {
      const stage = e.target.getStage();
      const pointerPosition = stage.getPointerPosition();
      const updatedImages = [...images];
      const gridCell = getCurrentGridLayout()[index];
      const relativeX = pointerPosition.x - gridCell.x;
      const relativeY = pointerPosition.y - gridCell.y;
      updatedImages[index].stickers.push({
        src: stickerImages[selectedStickerIndex],
        x: relativeX,
        y: relativeY,
        scale: 1,
        width: 72,
        height: 72,
      });
      setImages(updatedImages);
      setSelectedStickerIndex(null);
    } else {
      const updatedImages = [...images];
      const maxZIndex = Math.max(...images.map((img) => img.zIndex), 0) + 1;
      updatedImages.forEach((img) => (img.zIndex = img.zIndex === maxZIndex ? 0 : img.zIndex));
      updatedImages[index].zIndex = maxZIndex;
      setImages(updatedImages);
      setSelectedImageIndex(index);
      if (transformerRef.current) {
        transformerRef.current.nodes([imageRefs.current[index].current]);
        transformerRef.current.getLayer().batchDraw();
      }
    }
  };

  const handleStageClick = () => {
    setSelectedImageIndex(null);
    setSelectedStickerIndex(null);
    setSelectedSticker({ imageIndex: null, stickerIndex: null });
    setSelectedShapeIndex(null);
    setContextMenu({
      visible: false,
      x: 0,
      y: 0,
      type: null,
      stickerIndex: null,
      imageIndex: null,
      textIndex: null,
      shapeIndex: null,
    });
    if (transformerRef.current) transformerRef.current.nodes([]);
    if (stickerTransformerRef.current) stickerTransformerRef.current.nodes([]);
    if (textTransformerRef.current) textTransformerRef.current.nodes([]);
    if (shapeTransformerRef.current) shapeTransformerRef.current.nodes([]);
  };

  const handleDeleteSticker = () => {
    if (contextMenu.type === "sticker" && contextMenu.imageIndex !== null) {
      const updatedImages = [...images];
      updatedImages[contextMenu.imageIndex].stickers.splice(contextMenu.stickerIndex, 1);
      setImages(updatedImages);
    } else if (contextMenu.type === "text") {
      if (contextMenu.imageIndex === null) {
        const updated = [...texts];
        updated.splice(contextMenu.textIndex, 1);
        setTexts(updated);
      } else {
        const updated = [...images];
        updated[contextMenu.imageIndex].texts.splice(contextMenu.textIndex, 1);
        setImages(updated);
      }
    } else if (contextMenu.type === "shape") {
      const updated = [...shapes];
      updated.splice(contextMenu.shapeIndex, 1);
      setShapes(updated);
    }
    setContextMenu({
      visible: false,
      x: 0,
      y: 0,
      type: null,
      stickerIndex: null,
      imageIndex: null,
      textIndex: null,
      shapeIndex: null,
    });
  };

  const addShape = (contentType, shapeType) => {
    const newShape = {
      contentType,
      shapeType,
      x: 100,
      y: 100,
      width: 150,
      height: 100,
      fill: contentType === "text" ? "#ffffff" : "transparent",
      stroke: "#000000",
      strokeWidth: 2,
      text: contentType === "text" ? "Double click to edit" : "",
      fontSize: 16,
      textColor: "#000000",
      imageSrc: contentType === "image" ? "" : null,
      zIndex: Math.max(...shapes.map((s) => s.zIndex), 0) + 1,
    };
    setShapes([...shapes, newShape]);
    setShapeDialog({ visible: false, index: null, type: null, shapeType: null });
  };

  const updateShapeContent = (index, content) => {
    const updated = [...shapes];
    if (updated[index].contentType === "text") {
      updated[index].text = content;
    } else if (updated[index].contentType === "image") {
      updated[index].imageSrc = content;
    }
    setShapes(updated);
  };

  const updateShapeBackground = (index, color) => {
    const updated = [...shapes];
    updated[index].fill = color;
    setShapes(updated);
  };

  const updateShapeTextColor = (index, color) => {
    const updated = [...shapes];
    updated[index].textColor = color;
    setShapes(updated);
  };

  const renderShape = (shape) => {
    if (shape.shapeType === "rectangle") {
      return <Rect width={shape.width} height={shape.height} fill={shape.fill} stroke={shape.stroke} strokeWidth={shape.strokeWidth} />;
    } else if (shape.shapeType === "circle") {
      const radius = Math.min(shape.width, shape.height) / 2;
      return <Circle radius={radius} fill={shape.fill} stroke={shape.stroke} strokeWidth={shape.strokeWidth} />;
    }
  };

  return (
    <div className="flex">
      {/* Sidebar */}
      <div className="w-[250px] p-4 border-r space-y-4 bg-gray-100">
        <h2 className="font-bold text-lg">Options</h2>
        {/* Layout Controls */}
        <div>
          <h3 className="font-semibold">Layout</h3>
          <div className="flex items-center mt-1">
            <button onClick={removeGridCell} className="p-1 bg-white border rounded-l" disabled={gridCount <= 1}>
              -
            </button>
            <div className="flex-1 text-center bg-white border-t border-b py-1">{gridCount} Grid{gridCount !== 1 ? "s" : ""}</div>
            <button onClick={addGridCell} className="p-1 bg-white border rounded-r" disabled={gridCount >= 12}>
              +
            </button>
            <button onClick={shuffleGrid} className="p-1 bg-white border rounded ml-2" title="Shuffle Layout">
              ↺
            </button>
          </div>
        </div>
        {/* Background Switch */}
        <div>
          <h3 className="font-semibold">Background</h3>
          <button onClick={() => setBgUrl("https://images.unsplash.com/photo-1523413651479-597eb2da0ad6?w=1200&q=80")} className="block mt-1 p-1 bg-white border rounded">
            Scenic
          </button>
          <button onClick={() => setBgUrl("https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?w=1200&q=80")} className="block mt-1 p-1 bg-white border rounded">
            Beach
          </button>
        </div>
        {/* Stickers */}
        <div>
          <h3 className="font-semibold">Stickers</h3>
          {stickerImages.map((sticker, index) => (
            <div
              key={index}
              onClick={() => setSelectedStickerIndex(index)}
              className={`block mt-1 p-1 border rounded ${selectedStickerIndex === index ? "bg-blue-200" : "bg-white"}`}
            >
              <img src={sticker} alt={`Sticker ${index + 1}`} style={{ width: 32, height: 32 }} />
            </div>
          ))}
        </div>
        {/* Text */}
        <div>
          <h3 className="font-semibold">Text</h3>
          <button onClick={() => setTexts([...texts, { x: 100, y: 100, text: "New Text", fontSize: 24 }])} className="block mt-1 p-1 bg-white border rounded">
            Add Text to Background
          </button>
          <button
            onClick={() => {
              if (selectedImageIndex !== null) {
                const updated = [...images];
                updated[selectedImageIndex].texts.push({ x: 50, y: 50, text: "Grid Text", fontSize: 20 });
                setImages(updated);
              }
            }}
            className="block mt-1 p-1 bg-white border rounded"
          >
            Add Text to Grid
          </button>
        </div>
        {/* Shapes */}
        <div>
          <h3 className="font-semibold">Shapes</h3>
          <div className="grid grid-cols-2 gap-2">
            <button onClick={() => setShapeDialog({ visible: true, index: null, type: "text", shapeType: "rectangle" })} className="p-2 bg-white border rounded">
              Text Rectangle
            </button>
            <button onClick={() => setShapeDialog({ visible: true, index: null, type: "text", shapeType: "circle" })} className="p-2 bg-white border rounded">
              Text Circle
            </button>
            <button onClick={() => setShapeDialog({ visible: true, index: null, type: "image", shapeType: "rectangle" })} className="p-2 bg-white border rounded">
              Image Rectangle
            </button>
            <button onClick={() => setShapeDialog({ visible: true, index: null, type: "image", shapeType: "circle" })} className="p-2 bg-white border rounded">
              Image Circle
            </button>
          </div>
        </div>
      </div>

      {/* Canvas */}
      <div className="flex-1 flex justify-center items-center bg-gray-200">
        <Stage width={1200} height={800} onClick={handleStageClick}>
          <Layer>
            <KonvaImage image={bg} width={1200} height={800} />
            {/* Background texts */}
            {texts.map((t, ti) => (
              <Text
                key={`bg-text-${ti}`}
                {...t}
                draggable
                onDblClick={(e) => startEditingText(e.target, true, null, ti)}
                onContextMenu={(e) => {
                  e.evt.preventDefault();
                  setContextMenu({ visible: true, x: e.evt.clientX, y: e.evt.clientY, type: "text", textIndex: ti, imageIndex: null });
                }}
                onDragEnd={(e) => {
                  const updated = [...texts];
                  updated[ti].x = e.target.x();
                  updated[ti].y = e.target.y();
                  setTexts(updated);
                }}
                onTransformEnd={(e) => {
                  const node = e.target;
                  const updated = [...texts];
                  updated[ti].fontSize = node.fontSize() * node.scaleX();
                  node.scaleX(1);
                  node.scaleY(1);
                  setTexts(updated);
                }}
                onClick={(e) => {
                  e.cancelBubble = true;
                  if (textTransformerRef.current) {
                    textTransformerRef.current.nodes([e.target]);
                    textTransformerRef.current.getLayer().batchDraw();
                  }
                }}
              />
            ))}
            {/* Shapes */}
            {shapes.map((shape, si) => {
              shapeRefs.current[si] = shapeRefs.current[si] || React.createRef();
              return (
                <Group
                  key={`shape-${si}`}
                  ref={shapeRefs.current[si]}
                  x={shape.x}
                  y={shape.y}
                  width={shape.width}
                  height={shape.height}
                  draggable
                  onClick={(e) => {
                    e.cancelBubble = true;
                    setSelectedShapeIndex(si);
                    if (shapeTransformerRef.current) {
                      shapeTransformerRef.current.nodes([shapeRefs.current[si].current]);
                      shapeTransformerRef.current.getLayer().batchDraw();
                    }
                  }}
                  onDragEnd={(e) => {
                    const updated = [...shapes];
                    updated[si].x = e.target.x();
                    updated[si].y = e.target.y();
                    setShapes(updated);
                  }}
                  onTransformEnd={(e) => {
                    const node = e.target;
                    const updated = [...shapes];
                    updated[si].width = node.width() * node.scaleX();
                    updated[si].height = node.height() * node.scaleY();
                    node.scaleX(1);
                    node.scaleY(1);
                    setShapes(updated);
                  }}
                  onContextMenu={(e) => {
                    e.evt.preventDefault();
                    setContextMenu({ visible: true, x: e.evt.clientX, y: e.evt.clientY, type: "shape", shapeIndex: si });
                  }}
                  onDblClick={(e) => {
                    if (shape.contentType === "text") {
                      const stage = e.target.getStage();
                      const stageBox = stage.container().getBoundingClientRect();
                      const pos = e.target.absolutePosition();
                      const area = document.createElement("textarea");
                      document.body.appendChild(area);
                      area.value = shape.text;
                      area.style.position = "absolute";
                      area.style.top = stageBox.top + pos.y + "px";
                      area.style.left = stageBox.left + pos.x + "px";
                      area.style.width = shape.width + "px";
                      area.style.height = shape.height + "px";
                      area.style.fontSize = shape.fontSize + "px";
                      area.style.border = "1px solid #ccc";
                      area.style.background = shape.fill;
                      area.style.color = shape.textColor;
                      area.focus();
                      area.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") {
                          updateShapeContent(si, area.value);
                          document.body.removeChild(area);
                        }
                      });
                    } else if (shape.contentType === "image") {
                      const url = prompt("Enter image URL:");
                      if (url) updateShapeContent(si, url);
                    }
                  }}
                >
                  {renderShape(shape, si)}
                  {shape.contentType === "text" && (
                    <Text
                      text={shape.text}
                      fontSize={shape.fontSize}
                      fill={shape.textColor}
                      width={shape.width}
                      height={shape.height}
                      align="center"
                      verticalAlign="middle"
                      wrap="word"
                    />
                  )}
                  {shape.contentType === "image" && shape.imageSrc && (
                    <KonvaImage image={new window.Image()} width={shape.width} height={shape.height} />
                  )}
                </Group>
              );
            })}
            {/* Grid Frames */}
            {images.slice(0, gridCount).map((img, i) => {
              const frame = getCurrentGridLayout()[i];
              if (!frame) return null;
              const image = loadedImages[i] || loadedImages[loadedImages.length - 1];
              const isTopmost = img.zIndex === Math.max(...images.map((img) => img.zIndex), 0);
              return (
                <Group
                  key={i}
                  x={frame.x}
                  y={frame.y}
                  width={frame.width}
                  height={frame.height}
                  draggable
                  onClick={(e) => handleImageClick(i, e)}
                  ref={imageRefs.current[i]}
                  scaleX={img.scale}
                  scaleY={img.scale}
                  zIndex={img.zIndex}
                  opacity={isGridChanging ? 0.7 : 1}
                  shadowColor="black"
                  shadowBlur={isGridChanging ? 10 : 0}
                  shadowOpacity={isGridChanging ? 0.2 : 0}
                  transition="all 0.3s ease-in-out"
                >
                  {frame.shape === "circle" ? (
                    <Circle
                      x={frame.width / 2}
                      y={frame.height / 2}
                      radius={Math.min(frame.width, frame.height) / 2}
                      fill="white"
                      stroke={isTopmost ? "blue" : "#ddd"}
                      strokeWidth={isTopmost ? 2 : 1}
                    />
                  ) : (
                    <Rect width={frame.width} height={frame.height} fill="white" stroke={isTopmost ? "blue" : "#ddd"} strokeWidth={isTopmost ? 2 : 1} cornerRadius={8} />
                  )}
                  <KonvaImage image={image} width={frame.width} height={frame.height} cornerRadius={8} opacity={0.9} />
                  {img.stickers.map((sticker, sIndex) => {
                    const stickerImage = loadedStickers[stickerImages.indexOf(sticker.src)] || new Image();
                    return (
                      <KonvaImage
                        key={`sticker-${i}-${sIndex}`}
                        image={stickerImage}
                        x={sticker.x}
                        y={sticker.y}
                        width={sticker.width}
                        height={sticker.height}
                        scaleX={sticker.scale}
                        scaleY={sticker.scale}
                        draggable
                        onClick={(e) => {
                          e.cancelBubble = true;
                          setSelectedSticker({ imageIndex: i, stickerIndex: sIndex });
                          if (stickerTransformerRef.current) {
                            stickerTransformerRef.current.nodes([e.target]);
                            stickerTransformerRef.current.getLayer().batchDraw();
                          }
                        }}
                        onDragEnd={(e) => {
                          const updatedImages = [...images];
                          updatedImages[i].stickers[sIndex].x = e.target.x();
                          updatedImages[i].stickers[sIndex].y = e.target.y();
                          setImages(updatedImages);
                        }}
                        onTransformEnd={(e) => {
                          const node = e.target;
                          const updatedImages = [...images];
                          const stickerObj = updatedImages[i].stickers[sIndex];
                          stickerObj.width = node.width() * node.scaleX();
                          stickerObj.height = node.height() * node.scaleY();
                          node.scaleX(1);
                          node.scaleY(1);
                          setImages(updatedImages);
                        }}
                        onContextMenu={(e) => setContextMenu({ visible: true, x: e.evt.clientX, y: e.evt.clientY, type: "sticker", stickerIndex: sIndex, imageIndex: i })}
                      />
                    );
                  })}
                  {img.texts.map((t, ti) => (
                    <Text
                      key={`grid-text-${i}-${ti}`}
                      {...t}
                      draggable
                      onDblClick={(e) => startEditingText(e.target, false, i, ti)}
                      onContextMenu={(e) => {
                        e.evt.preventDefault();
                        setContextMenu({ visible: true, x: e.evt.clientX, y: e.evt.clientY, type: "text", textIndex: ti, imageIndex: i });
                      }}
                      onDragEnd={(e) => {
                        const updated = [...images];
                        updated[i].texts[ti].x = e.target.x();
                        updated[i].texts[ti].y = e.target.y();
                        setImages(updated);
                      }}
                      onTransformEnd={(e) => {
                        const node = e.target;
                        const updated = [...images];
                        updated[i].texts[ti].fontSize = node.fontSize() * node.scaleX();
                        node.scaleX(1);
                        node.scaleY(1);
                        setImages(updated);
                      }}
                      onClick={(e) => {
                        e.cancelBubble = true;
                        if (textTransformerRef.current) {
                          textTransformerRef.current.nodes([e.target]);
                          textTransformerRef.current.getLayer().batchDraw();
                        }
                      }}
                    />
                  ))}
                </Group>
              );
            })}
            <Text text="My Album" x={50} y={30} fontSize={32} fill="white" shadowColor="black" shadowBlur={4} />
            <Transformer ref={transformerRef} keepRatio={true} resizeEnabled={true} rotateEnabled={true} />
            <Transformer ref={stickerTransformerRef} resizeEnabled={true} rotateEnabled={true} />
            <Transformer ref={textTransformerRef} resizeEnabled={true} rotateEnabled={true} />
            <Transformer ref={shapeTransformerRef} resizeEnabled={true} rotateEnabled={true} />
          </Layer>
        </Stage>
        {/* Context Menu */}
        {contextMenu.visible && (
          <div
            style={{
              position: "absolute",
              top: contextMenu.y,
              left: contextMenu.x,
              zIndex: 20,
              background: "white",
              border: "1px solid #ccc",
              borderRadius: "4px",
              padding: "4px",
              boxShadow: "0 0 5px rgba(0,0,0,0.2)",
            }}
          >
            <div onClick={handleDeleteSticker} style={{ padding: "2px 8px", cursor: "pointer" }}>
              Delete {contextMenu.type}
            </div>
          </div>
        )}
        {/* Shape Dialog */}
        {shapeDialog.visible && (
          <div
            className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-40 z-50"
            onClick={() => setShapeDialog({ visible: false, index: null, type: null, shapeType: null })}
          >
            <div className="bg-white rounded-lg shadow-lg p-6 w-[320px] space-y-4" onClick={(e) => e.stopPropagation()}>
              <h3 className="font-bold text-lg mb-2">Add {shapeDialog.type} in {shapeDialog.shapeType}</h3>
              {shapeDialog.type === "text" ? (
                <>
                  <label className="block">
                    <span className="text-sm font-medium">Default Text</span>
                    <input type="text" defaultValue="Double click to edit" className="w-full mt-1 p-2 border rounded" />
                  </label>
                  <label className="block">
                    <span className="text-sm font-medium">Background Color</span>
                    <input type="color" defaultValue="#ffffff" className="w-full mt-1 p-1 border rounded" />
                  </label>
                  <label className="block">
                    <span className="text-sm font-medium">Text Color</span>
                    <input type="color" defaultValue="#000000" className="w-full mt-1 p-1 border rounded" />
                  </label>
                </>
              ) : (
                <label className="block">
                  <span className="text-sm font-medium">Image URL</span>
                  <input type="text" placeholder="Paste image URL" className="w-full mt-1 p-2 border rounded" />
                </label>
              )}
              <div className="flex justify-end space-x-2">
                <button
                  className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                  onClick={() => setShapeDialog({ visible: false, index: null, type: null, shapeType: null })}
                >
                  Cancel
                </button>
                <button
                  className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                  onClick={() => addShape(shapeDialog.type, shapeDialog.shapeType)}
                >
                  Add Shape
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}